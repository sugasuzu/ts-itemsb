# GNP-Based Time-Series Rule Mining System - プログラムフロー図

**作成日:** 2025-11-13
**対象プログラム:** main.c
**システム概要:** Genetic Network Programming (GNP) を用いた時系列ルールマイニング

---

## 全体構成

```
╔══════════════════════════════════════════════════════════════════════════════╗
║                   GNP-Based Time-Series Rule Mining System                   ║
║                        (Inter-transaction Association)                       ║
╚══════════════════════════════════════════════════════════════════════════════╝
```

---

## PHASE 1: データ読み込みと初期化

### メイン関数の開始

```
┌─────────────────┐
│ main()          │
└────────┬────────┘
         │
         ├─► データファイル読み込み (例: GBPJPY.txt)
         │   ├─ 60次元バイナリ属性 (20通貨ペア × 3状態)
         │   │  - Up/Stay/Down の3状態を各通貨ペアで表現
         │   ├─ X列: 日次リターン率 (%)
         │   └─ T列: タイムスタンプ (日付)
         │
         ├─► メモリ割り当て
         │   ├─ GNP個体群 (120個体)
         │   │  - 各個体は判定ノードと処理ノードで構成
         │   ├─ 未来統計配列 (4D配列)
         │   │  - future_sum[個体][ノード][深度][offset]
         │   │  - future_sum_sq[個体][ノード][深度][offset]
         │   │  - future_count[個体][ノード][深度][offset]
         │   └─ ルールプール (最大2002ルール)
         │
         └─► 初期化
             ├─ GNP構造の初期化 (ランダム)
             │  - ノード接続をランダムに設定
             │  - 属性と時間遅延をランダムに割り当て
             ├─ グローバルカウンタ初期化
             └─ 遅延学習の初期化
```

### データ構造

```
入力データ形式 (GBPJPY.txt):
┌────────────────────────────────────────────────────────────┐
│ GBPJPY_Up | GBPJPY_Stay | GBPJPY_Down | ... | X    | T    │
├────────────────────────────────────────────────────────────┤
│    1      |      0      |      0      | ... | 0.52 | 2010-01-04 │
│    0      |      1      |      0      | ... |-0.13 | 2010-01-05 │
│    0      |      0      |      1      | ... |-0.87 | 2010-01-06 │
└────────────────────────────────────────────────────────────┘
         60属性 (バイナリ)           リターン率  日付
```

---

## PHASE 2: GNP進化ループ (201世代)

### 進化の概要

```
┌─────────────────────────────────────────────────┐
│  for (generation = 0; generation < 201; g++)   │
└──────────────┬──────────────────────────────────┘
               │
               ├─► Step 1: 全個体の評価
               ├─► Step 2: ルール抽出
               └─► Step 3: 遺伝的操作
                   └─ 次世代へ
```

---

### Step 1: 全個体の評価 (evaluate_all_individuals)

```
┌──────────────────────────────────────────────────────────┐
│ 評価範囲: [MAX_TIME_DELAY, Nrd - FUTURE_SPAN)          │
│          = [5, 4130) (GBPJPY: 4125レコード)             │
└──────────────────────────────────────────────────────────┘

for each time_index in [5, 4130):
    │
    └─► evaluate_single_instance(time_index)
        │
        ├─► 全個体 (120個体) を評価
        │   for (individual = 0; i < 120; i++):
        │       │
        │       ├─ GNPノード遷移 (判定→処理)
        │       │  ┌─────────────────────────┐
        │       │  │ 判定ノード              │
        │       │  │ - 属性値をチェック      │
        │       │  │ - 時間遅延を適用        │
        │       │  │   (t-0, t-1, ..., t-5) │
        │       │  │ - 次ノードへ遷移        │
        │       │  └─────────────────────────┘
        │       │           ↓
        │       │  ┌─────────────────────────┐
        │       │  │ 処理ノード              │
        │       │  │ - 深度を記録            │
        │       │  │ - マッチカウント更新    │
        │       │  │ - 次ノードへ遷移        │
        │       │  └─────────────────────────┘
        │       │
        │       ├─ 属性条件チェック
        │       │  if (data[time_index - delay][attr_id] == 1):
        │       │      マッチ成立
        │       │
        │       └─ マッチカウント更新
        │           match_count[individual][node][depth]++
        │
        └─► 未来値の統計計算
            │
            ├─ accumulate_future_statistics()
            │  ├─ X(t+1) の合計を計算
            │  │  future_sum[...][0] += X[time_index + 1]
            │  │  future_sum_sq[...][0] += X[time_index + 1]²
            │  │
            │  └─ X(t+2) の合計を計算
            │     future_sum[...][1] += X[time_index + 2]
            │     future_sum_sq[...][1] += X[time_index + 2]²
            │
            └─ update_quadrant_statistics()
               ├─ Q1 (++): t+1≥0% AND t+2≥0%  (上昇継続)
               ├─ Q2 (-+): t+1<0% AND t+2≥0%  (反発)
               ├─ Q3 (--): t+1<0% AND t+2<0%  (下落継続)
               └─ Q4 (+-): t+1≥0% AND t+2<0%  (反転)

統計の計算:
    mean = sum / count
    sigma = sqrt(sum_sq/count - mean²)
```

---

### Step 2: ルール抽出 (extract_rules)

```
for each individual (120個体):
    for each processing node (10ノード):
        for each depth (1-8属性):
            │
            ├─► matched_count チェック
            │   if (matched_count < 1): skip
            │
            ├─► check_rule_quality() 🔍
            │   │
            │   ├─ Phase 2 Triple Rematch Fix:
            │   │   rematch_rule_pattern() を1回だけ実行
            │   │   │
            │   │   ┌─────────────────────────────────────────┐
            │   │   │ rematch_rule_pattern()                 │
            │   │   │ (修正済み: ルール固有範囲)              │
            │   │   ├─────────────────────────────────────────┤
            │   │   │ ① max_delayを計算                      │
            │   │   │    max_delay = 0                       │
            │   │   │    for each time_delay:                │
            │   │   │      max_delay = max(time_delay)       │
            │   │   │                                         │
            │   │   │ ② 範囲設定（論文準拠）                 │
            │   │   │    safe_start = max_delay              │
            │   │   │    safe_end = Nrd - FUTURE_SPAN        │
            │   │   │                                         │
            │   │   │    例: max_delay=3の場合               │
            │   │   │    → [3, 4130) の範囲でマッチング     │
            │   │   │                                         │
            │   │   │ ③ マッチング実行                       │
            │   │   │    for t in [safe_start, safe_end):    │
            │   │   │      if 全属性マッチ:                  │
            │   │   │        matched_indices[n++] = t        │
            │   │   │                                         │
            │   │   │ ④ 結果返却                             │
            │   │   │    return matched_count                │
            │   │   └─────────────────────────────────────────┘
            │   │
            │   ├─ Stage 1: 象限集中度チェック
            │   │   ├─ determine_quadrant_by_rate_with_concentration()
            │   │   │   │
            │   │   │   ├─ 0ベース象限判定 (純粋符号ベース)
            │   │   │   │  - Q1カウント (t+1≥0, t+2≥0)
            │   │   │   │  - Q2カウント (t+1<0, t+2≥0)
            │   │   │   │  - Q3カウント (t+1<0, t+2<0)
            │   │   │   │  - Q4カウント (t+1≥0, t+2<0)
            │   │   │   │
            │   │   │   ├─ 支配象限の決定
            │   │   │   │  dominant = max(Q1, Q2, Q3, Q4)
            │   │   │   │
            │   │   │   ├─ 集中率の計算
            │   │   │   │  concentration_rate = dominant / total
            │   │   │   │
            │   │   │   ├─ 集中率チェック
            │   │   │   │  if (concentration_rate < 50%): REJECT
            │   │   │   │
            │   │   │   └─ 逸脱制約チェック (±0.5%)
            │   │   │      支配象限と逆方向に0.5%以上逸脱する点:
            │   │   │      if 存在: REJECT
            │   │   │
            │   │   └─ if (集中率 < 50%): return 0 (除外)
            │   │
            │   ├─ Stage 2: サポート率チェック
            │   │   │
            │   │   ├─ calculate_accurate_support_rate() 🆕
            │   │   │   │
            │   │   │   ┌─────────────────────────────────────┐
            │   │   │   │ 論文準拠サポート率計算              │
            │   │   │   │ (式(3)準拠)                        │
            │   │   │   ├─────────────────────────────────────┤
            │   │   │   │ 入力:                               │
            │   │   │   │ - matched_count: マッチ数          │
            │   │   │   │ - time_delays: 時間遅延配列        │
            │   │   │   │ - num_attributes: 属性数           │
            │   │   │   │                                     │
            │   │   │   │ ① max_delay計算                    │
            │   │   │   │    (再計算: 確実性のため)          │
            │   │   │   │                                     │
            │   │   │   │ ② S_max(X∪Y)計算                  │
            │   │   │   │    S_max = max_delay +             │
            │   │   │   │            FUTURE_SPAN              │
            │   │   │   │                                     │
            │   │   │   │    例: max_delay=3, FUTURE_SPAN=2  │
            │   │   │   │    → S_max = 3 + 2 = 5             │
            │   │   │   │                                     │
            │   │   │   │ ③ effective_records計算            │
            │   │   │   │    eff = Nrd - S_max_XY            │
            │   │   │   │                                     │
            │   │   │   │    例: Nrd=4132, S_max=5           │
            │   │   │   │    → eff = 4132 - 5 = 4127         │
            │   │   │   │                                     │
            │   │   │   │ ④ サポート率返却                   │
            │   │   │   │    return matched / eff            │
            │   │   │   │                                     │
            │   │   │   │    例: matched=23, eff=4127        │
            │   │   │   │    → 0.00557 (0.557%)              │
            │   │   │   └─────────────────────────────────────┘
            │   │   │
            │   │   └─ if (support_rate < Minsup): REJECT
            │   │
            │   └─ return (matched_indices, concentration, count)
            │
            ├─► 重複チェック (check_rule_duplication)
            │   同一の属性・時間遅延の組み合わせをチェック
            │
            └─► if (!duplicate):
                │
                ├─ register_new_rule()
                │  ├─ ルールプールに登録
                │  │  rule_pool[idx].attributes = ...
                │  │  rule_pool[idx].time_delays = ...
                │  │
                │  ├─ サポート率保存
                │  │  (calculate_accurate_support_rate使用)
                │  │
                │  └─ 統計情報保存
                │     - mean, sigma, min, max (t+1, t+2)
                │     - support_count, support_rate
                │
                ├─ フィットネス更新
                │  fitness =
                │    + num_attributes        (1-8点)
                │    + support_rate × 10     (頻度)
                │    + concentration × 100   (集中度)
                │    + concentration_bonus   (0-10000, 非線形)
                │    + 20.0                  (新規ルールボーナス)
                │
                │  concentration_bonus計算:
                │  if (concentration_rate >= 0.45):
                │      excess = (concentration - 0.45) × 20
                │      bonus = excess² × 10000
                │
                │  例: concentration=50% → bonus=10000
                │      concentration=47.5% → bonus=2500
                │      concentration=45% → bonus=0
                │
                └─ collect_matched_indices() 🔍
                   (検証用マッチインデックス収集)
                   │
                   ┌─────────────────────────────────────┐
                   │ collect_matched_indices()          │
                   │ (修正済み: ルール固有範囲)          │
                   ├─────────────────────────────────────┤
                   │ rematch_rule_pattern()と同じ       │
                   │ ロジックで再マッチング              │
                   │                                     │
                   │ ルール固有のmax_delayに基づき       │
                   │ 範囲 [max_delay, Nrd-FUTURE_SPAN)  │
                   │ でマッチング                        │
                   │                                     │
                   │ matched_indicesを                   │
                   │ rule_pool[idx]に保存                │
                   │ (検証用CSVファイル出力に使用)       │
                   └─────────────────────────────────────┘
```

---

### Step 3: 遺伝的操作

```
┌──────────────────────────────────────────────┐
│ 選択 (Selection)                             │
├──────────────────────────────────────────────┤
│ ├─ エリート保存                              │
│ │  - 上位個体を次世代に引き継ぐ              │
│ │                                             │
│ └─ トーナメント選択                          │
│    - ランダムに複数個体を選択                │
│    - 最も適応度が高い個体を選ぶ              │
└──────────────────────────────────────────────┘
         ↓
┌──────────────────────────────────────────────┐
│ 交叉 (Crossover)                             │
├──────────────────────────────────────────────┤
│ - 2つの親個体のノード接続を組み換え         │
│ - 判定ノードと処理ノードの接続を交換        │
└──────────────────────────────────────────────┘
         ↓
┌──────────────────────────────────────────────┐
│ 突然変異 (Mutation)                          │
├──────────────────────────────────────────────┤
│ ├─ ノード機能変更                            │
│ │  - 判定ノードの属性を変更                  │
│ │                                             │
│ ├─ 属性変更                                  │
│ │  - 使用する属性をランダムに変更            │
│ │  - 60種類の属性から選択                    │
│ │                                             │
│ └─ 時間遅延変更 🔄                           │
│    - t-0, t-1, t-2, t-3, t-4, t-5           │
│    - ランダムに遅延を変更                    │
│    - これにより異なるmax_delayのルール生成   │
└──────────────────────────────────────────────┘
         ↓
    (次世代へ → Step 1に戻る)
```

---

## PHASE 3: 最終出力

### 出力処理

```
┌─────────────────┐
│ write_results() │
└────────┬────────┘
         │
         ├─► ルールプール出力
         │   ├─ ファイル: output/GBPJPY/pool/zrp01a.txt
         │   │
         │   └─ 形式 (TSV):
         │       ┌─────────────────────────────────────────┐
         │       │ Attr1  Attr2  ...  Attr8                │
         │       │ X(t+1)_mean  X(t+1)_sigma               │
         │       │ X(t+1)_min   X(t+1)_max                 │
         │       │ X(t+2)_mean  X(t+2)_sigma               │
         │       │ X(t+2)_min   X(t+2)_max                 │
         │       │ support_count  support_rate             │
         │       │ Negative  HighSup  LowVar  NumAttr      │
         │       ├─────────────────────────────────────────┤
         │       │ GBPJPY_Up(t-2)  USDJPY_Up(t-3)  ...     │
         │       │ 0.368  0.562  -10.040  4.520  ...       │
         │       │ 22  0.0053  0  0  0  7                  │
         │       └─────────────────────────────────────────┘
         │
         ├─► 検証データ出力
         │   ├─ ファイル: output/GBPJPY/verification/rule_XXXX.csv
         │   │
         │   └─ 形式 (CSV):
         │       ┌─────────────────────────────────────────┐
         │       │ Time_Index, X_t1, X_t2, Timestamp       │
         │       ├─────────────────────────────────────────┤
         │       │ 245, 0.0012, 0.0015, 2010-03-15         │
         │       │ 389, 0.0008, 0.0018, 2010-06-22         │
         │       │ ...                                     │
         │       └─────────────────────────────────────────┘
         │       (ルールがマッチした全時点を記録)
         │
         └─► 統計レポート
             ├─ フィルタ統計
             │  - 象限集中度フィルタで除外された数
             │  - サポート率フィルタで除外された数
             │  - 通過したルール数
             │
             ├─ 属性使用頻度
             │  - 各属性が何回使用されたか
             │  - 遅延学習の統計
             │
             └─ 成功率
                - 新規ルール数
                - 重複ルール数
                - 世代ごとの進化状況
```

---

## 時間軸の概念図

```
◄────────── X (過去: 条件部) ──────────┤現在┤────── Y (未来: 結論部) ──────►

t-max_delay  ...  t-2  t-1  t-0        │       t+1  t+2
├─────────────────────────────────────┼───────────┤
│                                     │           │
│     過去参照範囲                    │   未来予測範囲
│  (max_delay ステップ)               │   (FUTURE_SPAN=2)
│                                     │
│  例: GBPJPY_Up(t-5)                │   X(t+1), X(t+2)
│      USDJPY_Up(t-3)                │   を予測
│      EURJPY_Up(t-2)                │
│                                     │
└─────────────────────────────────────┴───────────┘
            S_max(X∪Y) = max_delay + FUTURE_SPAN

論文の式(3):
    support'(X) = t'(X) / (N - S_max(X∪Y))

where:
    t'(X):        マッチ数 (XとYが両方範囲内のトランザクション)
    N:            全トランザクション数 (Nrd)
    S_max(X∪Y):   ルール全体の時間スパン
```

---

## 象限分類の詳細

```
┌──────────────────────────────────────────────────────────┐
│ 4象限分類（0ベース：純粋符号ベース）                     │
├──────────────────────────────────────────────────────────┤
│                                                          │
│         t+2                                              │
│          ▲                                               │
│          │                                               │
│   Q2 (-+)│ Q1 (++)                                      │
│    反発  │  上昇継続                                     │
│          │                                               │
│  ────────┼──────────► t+1                              │
│          │                                               │
│   Q3 (--)│ Q4 (+-)                                      │
│   下落継続│  反転                                        │
│          │                                               │
│                                                          │
├──────────────────────────────────────────────────────────┤
│ Q1 (++): t+1 ≥ 0.0% AND t+2 ≥ 0.0%  → 上昇トレンド継続  │
│ Q2 (-+): t+1 < 0.0% AND t+2 ≥ 0.0%  → 下落後の反発      │
│ Q3 (--): t+1 < 0.0% AND t+2 < 0.0%  → 下落トレンド継続  │
│ Q4 (+-): t+1 ≥ 0.0% AND t+2 < 0.0%  → 上昇後の反転      │
└──────────────────────────────────────────────────────────┘

集中率の計算:
    concentration_rate = max(Q1, Q2, Q3, Q4) / total

    要件: concentration_rate ≥ 50% (過半数が1つの象限に集中)

逸脱制約:
    支配象限と逆方向に0.5%以上逸脱する点が存在しない

    例: 支配象限がQ1 (++)の場合
        - t+1 < -0.5% または t+2 < -0.5% の点があれば除外
```

---

## データフロー図

```
┌─────────────┐
│ 入力データ  │
│ GBPJPY.txt  │
└──────┬──────┘
       │
       ├─► 60次元バイナリ属性
       │   + リターン率X
       │   + タイムスタンプT
       │
       ▼
┌──────────────────────┐
│ GNP進化ループ        │
│ (201世代)            │
├──────────────────────┤
│ 各世代で:            │
│ - 個体評価           │
│ - ルール抽出         │
│ - 遺伝的操作         │
└──────┬───────────────┘
       │
       ├─► マッチング (ルール固有範囲)
       │   [max_delay, Nrd-FUTURE_SPAN)
       │
       ├─► 象限集中度フィルタ
       │   concentration ≥ 50%
       │   deviation ≤ 0.5%
       │
       ├─► サポート率フィルタ
       │   support_rate ≥ Minsup
       │
       ▼
┌──────────────────────┐
│ ルールプール         │
│ (最大2002ルール)     │
├──────────────────────┤
│ 各ルール:            │
│ - 属性組み合わせ     │
│ - 時間遅延           │
│ - 統計情報           │
│ - サポート率         │
│ - 集中率             │
└──────┬───────────────┘
       │
       ▼
┌──────────────────────┐
│ 出力ファイル         │
├──────────────────────┤
│ - zrp01a.txt         │
│   (ルールプール)     │
│                      │
│ - rule_XXXX.csv      │
│   (検証データ)       │
└──────────────────────┘
```

---

## 主要な修正点（2025-11-13実装）

### 1. サポート率計算の論文準拠化

```
修正前:
    support_rate = matched_count / (Nrd - FUTURE_SPAN)  // 固定分母

修正後:
    support_rate = calculate_accurate_support_rate(
        matched_count, time_delays, num_attributes
    )

    内部処理:
    ① max_delay = max(time_delays)
    ② S_max_XY = max_delay + FUTURE_SPAN
    ③ effective_records = Nrd - S_max_XY
    ④ return matched_count / effective_records
```

### 2. マッチング範囲の動的調整

```
修正前:
    safe_start = MAX_TIME_DELAY (= 5)  // 固定範囲
    safe_end = Nrd - FUTURE_SPAN

修正後:
    max_delay = max(time_delays)       // ルール固有
    safe_start = max_delay
    safe_end = Nrd - FUTURE_SPAN

効果:
    - max_delay=0のルール: [0, Nrd-2)  → 最大範囲でマッチング
    - max_delay=1のルール: [1, Nrd-2)
    - max_delay=5のルール: [5, Nrd-2)  → 従来と同じ
```

---

## 実行例

```bash
# コンパイル
$ make clean && make

# 実行（通貨ペアを指定）
$ ./main GBPJPY

# 出力
# - 201世代のGNP進化
# - ルール抽出とフィルタリング
# - 最終ルールプールの出力
# - 検証データの出力
```

---

## 出力ファイルの構造

```
output/GBPJPY/
├── pool/
│   └── zrp01a.txt          # ルールプール（全ルール）
├── verification/
│   ├── rule_0001.csv       # ルール1の検証データ
│   ├── rule_0002.csv       # ルール2の検証データ
│   └── ...
├── IA/
│   └── statistics.txt      # 統計レポート
└── doc/
    └── summary.txt         # 実行サマリ
```

---

## パラメータ設定

```c
// GNPパラメータ
#define Generation 201       // 世代数
#define Nkotai 120          // 個体数

// 時系列パラメータ
#define MAX_TIME_DELAY 5    // 最大時間遅延
#define FUTURE_SPAN 2       // 未来予測スパン (t+1, t+2)

// フィルタリング閾値
#define Minsup 0.005        // 最小サポート率 (0.5%)
#define MIN_CONCENTRATION 0.50  // 最小集中率 (50%)
#define MAX_DEVIATION 0.5   // 最大逸脱率 (0.5%)

// ルールプール
#define Nrulemax 2002       // 最大ルール数
```

---

**文書バージョン:** 1.0
**最終更新:** 2025-11-13
**対応コード:** main.c (論文準拠サポート率計算実装後)
